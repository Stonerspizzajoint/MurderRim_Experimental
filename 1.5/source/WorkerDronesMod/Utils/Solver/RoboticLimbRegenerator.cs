using System.Collections.Generic;
using System.Linq;
using RimWorld;
using Verse;

namespace WorkerDronesMod
{
    public static class RoboticLimbRegenerator
    {
        // Reconstruction parameters.
        private const float BaseSeverityPerTick = 0.015f;
        private const float BaseHeatPerCoverage = 0.28f;
        private const float SeverityHeatFactor = 0.1f;

        // Hediff definitions.
        private static readonly HediffDef ReconstructionDef = MD_DefOf.MD_RoboticReconstruction;
        private static readonly HediffDef FleshyPartDef = MD_DefOf.MD_FleshyPart;
        private static readonly HediffDef MissingBodyPartDef = HediffDefOf.MissingBodyPart;
        private static readonly BodyPartDef StomachDef = MD_DefOf.Stomach;

        // For each pawn, a queue of missing body parts to process.
        private static Dictionary<Pawn, Queue<BodyPartRecord>> regenerationQueues =
            new Dictionary<Pawn, Queue<BodyPartRecord>>();

        /// <summary>
        /// Processes regeneration for the pawn by managing the missing parts queue and processing the current part.
        /// </summary>
        public static void ProcessRegeneration(Pawn pawn)
        {
            if (pawn == null || pawn.Dead || pawn.health == null)
            {
                if (DebugSettings.godMode)
                    Log.Message("[RoboticLimbRegenerator] Pawn is null, dead, or has no health component.");
                return;
            }

            // If no regeneration queue exists, build one from the missing parts.
            if (!regenerationQueues.ContainsKey(pawn) || regenerationQueues[pawn] == null || !regenerationQueues[pawn].Any())
            {
                BuildNewQueue(pawn);
                if (DebugSettings.godMode)
                    Log.Message($"[RoboticLimbRegenerator] Built regeneration queue for pawn {pawn.LabelShort}. Queue size: {regenerationQueues[pawn].Count}");
            }

            // Build a list of parts to process.
            // We'll include:
            //  (a) Parts in the regeneration queue (i.e. missing parts)
            //  (b) Parts that are not missing but already have the reconstruction hediff and are not yet fully regenerated.
            List<BodyPartRecord> readyParts = new List<BodyPartRecord>();

            // (a) Add missing parts from the regeneration queue.
            readyParts.AddRange(regenerationQueues[pawn].ToList());

            // (b) Add parts that already have the reconstruction hediff.
            var reconParts = pawn.health.hediffSet.hediffs
                .Where(h => h.def == ReconstructionDef && h.Part != null && !pawn.health.hediffSet.PartIsMissing(h.Part) && h.Severity < 1f)
                .Select(h => h.Part);
            foreach (var part in reconParts)
            {
                if (!readyParts.Contains(part))
                    readyParts.Add(part);
            }

            if (!readyParts.Any())
            {
                if (DebugSettings.godMode)
                    Log.Message($"[RoboticLimbRegenerator] No parts are ready for regeneration on {pawn.LabelShort}.");
                return;
            }

            // Process regeneration for each ready part.
            foreach (var part in readyParts)
            {
                ProcessRegenerationForPart(pawn, part);
            }
        }

        /// <summary>
        /// Calculates the total heat generated by all active reconstruction hediffs on the pawn.
        /// </summary>
        public static float CalculateHeatForPawn(Pawn pawn)
        {
            float totalHeat = 0f;
            foreach (var hediff in pawn.health.hediffSet.hediffs)
            {
                if (hediff.def == ReconstructionDef && hediff.Part != null)
                {
                    totalHeat += CalculatePartHeat(hediff.Part.coverage, hediff.Severity);
                }
            }
            return totalHeat;
        }

        /// <summary>
        /// Calculates heat for a given part based on its coverage and current reconstruction severity.
        /// Lower severity yields higher heat and vice versa.
        /// </summary>
        private static float CalculatePartHeat(float coverage, float severity)
        {
            return BaseHeatPerCoverage * coverage * (1 - (severity * SeverityHeatFactor));
        }

        /// <summary>
        /// Processes regeneration for a single body part.
        /// </summary>
        public static void ProcessRegenerationForPart(Pawn pawn, BodyPartRecord part)
        {
            // Skip the stomach for safety.
            if (part.def == StomachDef)
                return;

            // If the part is missing, restore it and remove its MissingBodyPart hediff.
            if (pawn.health.hediffSet.PartIsMissing(part))
            {
                if (DebugSettings.godMode)
                    Log.Message($"[RoboticLimbRegenerator] {part.def.defName} is missing. Restoring it for pawn {pawn.LabelShort}.");
                pawn.health.RestorePart(part);

                var missingHediff = pawn.health.hediffSet.hediffs
                    .FirstOrDefault(h => h.def == MissingBodyPartDef && h.Part == part);
                if (missingHediff != null)
                {
                    pawn.health.RemoveHediff(missingHediff);
                    if (DebugSettings.godMode)
                        Log.Message($"[RoboticLimbRegenerator] Removed MissingBodyPart from {part.def.defName}.");
                }

                // Apply the reconstruction hediff if necessary.
                if (!pawn.health.hediffSet.HasHediff(ReconstructionDef, part))
                {
                    ApplyReconstructionHediff(pawn, part);
                }
            }
            else
            {
                if (DebugSettings.godMode)
                    Log.Message($"[RoboticLimbRegenerator] {part.def.defName} is present on pawn {pawn.LabelShort}. Using active reconstruction.");
            }

            // Increase the severity of the reconstruction hediff.
            Hediff reconstructionHediff = GetReconstructionHediff(pawn, part);
            if (reconstructionHediff != null)
            {
                reconstructionHediff.Severity += BaseSeverityPerTick;
                if (DebugSettings.godMode)
                    Log.Message($"[RoboticLimbRegenerator] Increased severity on {part.def.defName} to {reconstructionHediff.Severity:0.###}.");

                // Finalize reconstruction if the severity reaches or exceeds 1.
                if (reconstructionHediff.Severity >= 1f)
                {
                    FinalizeReconstruction(pawn, part, reconstructionHediff);
                }
            }
            else
            {
                if (DebugSettings.godMode)
                    Log.Message($"[RoboticLimbRegenerator] No reconstruction hediff found on {part.def.defName}. Applying it now.");
                ApplyReconstructionHediff(pawn, part);
            }
        }

        /// <summary>
        /// Finalizes reconstruction by removing the reconstruction hediff,
        /// applying the fleshy part hediff, and enqueuing any missing child parts.
        /// </summary>
        private static void FinalizeReconstruction(Pawn pawn, BodyPartRecord part, Hediff reconstructionHediff)
        {
            // Remove the reconstruction hediff.
            pawn.health.RemoveHediff(reconstructionHediff);

            // Check if the regeneration queue for this pawn exists and is non-empty before dequeuing.
            if (regenerationQueues.ContainsKey(pawn) && regenerationQueues[pawn].Any())
            {
                regenerationQueues[pawn].Dequeue();
            }
            else if (DebugSettings.godMode)
            {
                Log.Message($"[RoboticLimbRegenerator] Regeneration queue not found or empty for pawn {pawn.LabelShort} during FinalizeReconstruction.");
            }

            if (DebugSettings.godMode)
                Log.Message($"[RoboticLimbRegenerator] Finalized reconstruction on {part.def.defName} for pawn {pawn.LabelShort}. Reconstruction hediff removed and part dequeued.");

            // Apply the fleshy part hediff if not already present.
            if (!pawn.health.hediffSet.HasHediff(FleshyPartDef, part))
            {
                var fleshyHediff = HediffMaker.MakeHediff(FleshyPartDef, pawn, part);
                fleshyHediff.Severity = 0.01f;
                pawn.health.AddHediff(fleshyHediff, part);
                if (DebugSettings.godMode)
                    Log.Message($"[RoboticLimbRegenerator] Applied FleshyPart hediff to {part.def.defName} for pawn {pawn.LabelShort}.");
            }
            else
            {
                if (DebugSettings.godMode)
                    Log.Message($"[RoboticLimbRegenerator] Pawn {pawn.LabelShort} already has FleshyPart hediff on {part.def.defName}.");
            }

            // Enqueue any missing child parts.
            EnqueueMissingChildParts(pawn, part);
        }

        /// <summary>
        /// Enqueues any missing child parts of the specified parent part.
        /// </summary>
        private static void EnqueueMissingChildParts(Pawn pawn, BodyPartRecord parentPart)
        {
            var missingChildren = parentPart.parts
                .Where(child => pawn.health.hediffSet.PartIsMissing(child))
                .OrderBy(child => GetBodyPartDepth(child));

            foreach (var child in missingChildren)
            {
                // Also skip any children that are stomachs.
                if (child.def == StomachDef)
                {
                    if (DebugSettings.godMode)
                        Log.Message($"[RoboticLimbRegenerator] Skipping enqueuing stomach child part {child.def.defName} for pawn {pawn.LabelShort}.");
                    continue;
                }
                regenerationQueues[pawn].Enqueue(child);
                if (DebugSettings.godMode)
                    Log.Message($"[RoboticLimbRegenerator] Enqueued missing child part {child.def.defName} for pawn {pawn.LabelShort}.");
            }
        }

        /// <summary>
        /// Applies the reconstruction hediff to the specified body part.
        /// </summary>
        private static void ApplyReconstructionHediff(Pawn pawn, BodyPartRecord part)
        {
            var reconstructionHediff = HediffMaker.MakeHediff(ReconstructionDef, pawn, part);
            reconstructionHediff.Severity = 0.01f; // Start at a low severity.
            pawn.health.AddHediff(reconstructionHediff, part);
            if (DebugSettings.godMode)
                Log.Message($"[RoboticLimbRegenerator] Applied reconstruction hediff to {part.def.defName} for pawn {pawn.LabelShort}.");
        }

        /// <summary>
        /// Retrieves the reconstruction hediff on the specified body part.
        /// </summary>
        private static Hediff GetReconstructionHediff(Pawn pawn, BodyPartRecord part)
        {
            return pawn.health.hediffSet.hediffs.FirstOrDefault(h => h.def == ReconstructionDef && h.Part == part);
        }

        /// <summary>
        /// Builds a new queue of missing body parts for the pawn.
        /// Only parts whose parent is not missing are included, and the stomach is excluded.
        /// </summary>
        private static void BuildNewQueue(Pawn pawn)
        {
            var missingParts = pawn.health.hediffSet.GetMissingPartsCommonAncestors()
                .Where(mp => mp.Part.def != StomachDef &&
                             (mp.Part.parent == null || !pawn.health.hediffSet.PartIsMissing(mp.Part.parent)))
                .Select(mp => mp.Part)
                .OrderBy(part => GetBodyPartDepth(part));

            regenerationQueues[pawn] = new Queue<BodyPartRecord>(missingParts);
            if (DebugSettings.godMode)
                Log.Message($"[RoboticLimbRegenerator] Built regeneration queue for pawn {pawn.LabelShort}. Queue size: {regenerationQueues[pawn].Count}");
        }

        /// <summary>
        /// Determines the depth of the body part in the hierarchy.
        /// </summary>
        private static int GetBodyPartDepth(BodyPartRecord part)
        {
            int depth = 0;
            while (part.parent != null)
            {
                depth++;
                part = part.parent;
            }
            return depth;
        }
    }
}










